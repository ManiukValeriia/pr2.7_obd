# pr2.7_obd
# ПРАКТИЧНА РОБОТА № 7
# Обмеження цілісності в реляційних базах даних

**Короткий опис**

У цій практичні роботі розглянуто реалізацію обмежень цілісності в реляційній базі даних для свиноферми. Було класифіковано обмеження, проаналізовано 
їхню роль у забезпеченні коректності даних та реалізовано приклади декларативної і процедурної підтримки. Особливу увагу приділено часу перевірки (негайна 
та відкладена) та області дії обмежень. Усі приклади протестовано в середовищі MSSQL, а результати оформлено у вигляді SQL-файлів.

**Завдання 2**

Обмеження у базі даних — це правила, які застосовуються до даних для забезпечення їх цілісності, достовірності та відповідності бізнес-логіці. Вони визначають 
умови, яким мають відповідати дані, щоб запобігти введенню некоректних або несумісних даних.

Класифікація обмежень:

1. За типом цілісності: 
- Обмеження доменної цілісності: Визначають допустимі значення для певного атрибута (стовпця). Наприклад, CHECK, NOT NULL.
- Обмеження посилкової цілісності: Забезпечують коректність зв’язків між таблицями через зовнішні ключі (FOREIGN KEY).
- Обмеження сутнісної цілісності: Гарантують унікальність записів у таблиці через первинні ключі (PRIMARY KEY) або унікальні ключі (UNIQUE).
- Обмеження користувацької цілісності: Визначають специфічні бізнес-правила, які не охоплюються іншими типами (реалізуються через тригери або процедури).

2. За способом реалізації: 
- Декларативні: Визначаються в структурі таблиці за допомогою ключових слів (PRIMARY KEY, FOREIGN KEY, CHECK, NOT NULL, UNIQUE).
- Процедурні: Реалізуються через тригери, збережені процедури або функції.
  
3. За часом перевірки: 
- Негайні (IMMEDIATE): Перевіряються одразу після виконання операції (наприклад, вставки чи оновлення).
- Відкладені (DEFERRED): Перевіряються після завершення транзакції.
  
4. За областю дії: 
- Обмеження домена: Обмеження на значення окремого атрибута (наприклад, тип даних або CHECK).
- Обмеження атрибута: Обмеження на один стовпець (наприклад, NOT NULL).
- Обмеження кортежу: Обмеження на комбінацію значень у рядку (наприклад, CHECK для кількох стовпців).
- Обмеження відношення: Обмеження на всю таблицю (наприклад, PRIMARY KEY, UNIQUE).
- Обмеження бази даних: Обмеження, що стосуються кількох таблиць (наприклад, FOREIGN KEY).


**Завдання 3**

BEGIN TRANSACTION;
BEGIN TRY
    -- Додаємо нову тварину
    INSERT INTO Animal (Nickname, Gender, Age, Purpose, FatherNickname, MotherNickname)
    VALUES ('Boris', 'male', 2, 'breeding', 'unknown', 'unknown');

    -- Отримуємо ID нової тварини
    DECLARE @NewAnimalID INT = SCOPE_IDENTITY();

    -- Додаємо запис про вакцинацію
    INSERT INTO Vaccination (AnimalID, VaccineName, VaccinationDate)
    VALUES (@NewAnimalID, 'Parvo', '2025-05-20');

    -- Підтверджуємо транзакцію
    COMMIT TRANSACTION;
END TRY
BEGIN CATCH
    -- У разі помилки скасовуємо транзакцію
    ROLLBACK TRANSACTION;
    -- Виводимо повідомлення про помилку
    SELECT ERROR_MESSAGE() AS ErrorMessage;
END CATCH;

**Завдання 4**

Декларативні обмеження визначаються у структурі таблиці за допомогою ключових слів (PRIMARY KEY, FOREIGN KEY, CHECK, NOT NULL, UNIQUE). Вони автоматично перевіряються СУБД.
Приклад для бази даних: У наданій базі даних уже є декларативні обмеження. Наведу їх із поясненнями та додам приклади для таблиці Students.

1.Обмеження для таблиці Animal: 
oPRIMARY KEY (AnimalID): Гарантує унікальність кожного запису про тварину.
oUNIQUE (Nickname): Забезпечує унікальність клички тварини.
oCHECK (Gender IN ('male', 'female')): Обмежує значення стовпця Gender до male або female.
oCHECK (Purpose IN ('slaughter', 'sale', 'breeding')): Обмежує значення стовпця Purpose.

2.Обмеження для таблиці Students (з завдання):

CREATE TABLE Groups (
    GroupID INT PRIMARY KEY,
    GroupName VARCHAR(50) NOT NULL
);

CREATE TABLE Students (
    StudentID INT PRIMARY KEY,
    Name NVARCHAR(100) NOT NULL,
    Age INT CHECK (Age >= 17),
    GroupID INT,
    CONSTRAINT FK_Group FOREIGN KEY (GroupID) REFERENCES Groups(GroupID)
);

**Завдання 5**

Процедурна підтримка реалізується через тригери, збережені процедури або функції для забезпечення складних бізнес-правил, які не можна реалізувати декларативно.

Опис бізнес-правил для бази даних:

1. Забезпечити, що тварини з призначенням breeding мають вік не менше 1 року.
2. Перевіряти, що PigletsCount не може бути більше 15 для однієї свині.
3. Заборонити вакцинацію тварин молодше 1 місяця.
4. Переконатися, що доглядач не може бути призначений більше ніж на 5 тварин.
5. Перевіряти, що вага тварини не може бути від’ємною або перевищувати 500 кг.
6. Заборонити зміну FatherNickname або MotherNickname на значення, які не існують у таблиці Animal.
7. Переконатися, що тварини з призначенням slaughter не можуть мати PigletsCount більше 0.
8. Заборонити додавання корму для тварини, якщо її вік менше 1 місяця.
9. Перевіряти, що дата вакцинації не може бути пізніше поточної дати.
10. Забезпечити, що тварина не може бути одночасно батьком і матір’ю іншої тварини.

Опис реалізації:
Для кожного правила створюється тригер (AFTER INSERT, AFTER UPDATE) або збережена процедура, яка перевіряє відповідність умові перед внесенням або зміною даних.
Наприклад, для правила 1: тригер перевіряє поле Age при вставці або оновленні запису в таблиці Animal і скасовує операцію, якщо тварина з призначенням breeding 
молодша 1 року. Для правила 4: тригер на таблиці Caretaker підраховує кількість тварин, призначених доглядачу, і скасовує вставку, якщо їх більше 5.

**Завдання 6**

Негайні обмеження (IMMEDIATE): Перевіряються одразу після виконання операції (вставки, оновлення, видалення). Наприклад, CHECK, NOT NULL, FOREIGN KEY за 
замовчуванням перевіряються негайно. 
Відкладені обмеження (DEFERRED): Перевіряються після завершення транзакції, що дозволяє тимчасово порушувати обмеження під час транзакції. Використовується 
для складних операцій, де спочатку потрібно внести дані, а потім перевірити їх цілісність.

-- Негайна перевірка
CREATE TABLE Animal (
    AnimalID INT IDENTITY(1,1) PRIMARY KEY,
    Nickname VARCHAR(50) UNIQUE NOT NULL,
    Gender CHAR(6) NOT NULL CHECK (Gender IN ('male', 'female')),
    Age INT NOT NULL CHECK (Age >= 0)
);

-- Відкладена перевірка
CREATE TABLE Family (
    FamilyID INT IDENTITY(1,1) PRIMARY KEY,
    AnimalID INT NOT NULL,
    FatherID INT,
    MotherID INT,
    CONSTRAINT FK_Animal FOREIGN KEY (AnimalID) REFERENCES Animal(AnimalID),
    CONSTRAINT FK_Father FOREIGN KEY (FatherID) REFERENCES Animal(AnimalID) DEFERRABLE INITIALLY DEFERRED,
    CONSTRAINT FK_Mother FOREIGN KEY (MotherID) REFERENCES Animal(AnimalID) DEFERRABLE INITIALLY DEFERRED
);

-- Увімкнення відкладеної перевірки
SET CONSTRAINTS FK_Father, FK_Mother DEFERRED;

-- Приклад транзакції з відкладеною перевіркою
BEGIN TRANSACTION;
    INSERT INTO Animal (Nickname, Gender, Age, Purpose) VALUES ('Max', 'male', 2, 'breeding');
    DECLARE @NewAnimalID INT = SCOPE_IDENTITY();
    INSERT INTO Family (AnimalID, FatherID) VALUES (@NewAnimalID, @NewAnimalID); -- Тимчасово порушуємо
COMMIT TRANSACTION; -- Перевірка відбудеться тут

**Завдання 7**

Обмеження домена: Визначає допустимі значення для стовпця (наприклад, тип даних, CHECK).
Приклад: CHECK (Gender IN ('male', 'female')) у таблиці Animal.

Обмеження атрибута: Застосовується до окремого стовпця (наприклад, NOT NULL, UNIQUE).
Приклад: Nickname VARCHAR(50) UNIQUE NOT NULL у таблиці Animal.

Обмеження кортежу: Обмеження на комбінацію значень у рядку.
Приклад: Перевірка, що PigletsCount не може бути більше 0, якщо Purpose = 'slaughter'.

Обмеження відношення: Застосовується до всієї таблиці (наприклад, PRIMARY KEY, UNIQUE).
Приклад: PRIMARY KEY (AnimalID) у таблиці Animal.


Обмеження бази даних: Застосовується до кількох таблиць (наприклад, FOREIGN KEY).
Приклад: FOREIGN KEY (AnimalID) REFERENCES Animal(AnimalID) у таблиці Vaccination.
